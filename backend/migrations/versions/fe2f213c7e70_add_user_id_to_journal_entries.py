"""Add user_id to journal_entries

Revision ID: fe2f213c7e70
Revises: 7c96d553b665
Create Date: 2025-07-31 15:41:08.064067

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy import text


# revision identifiers, used by Alembic.
revision = 'fe2f213c7e70'
down_revision = '7c96d553b665'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Step 1: Check if user_id column already exists
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    columns = [col['name'] for col in inspector.get_columns('journal_entries')]
    
    if 'user_id' in columns:
        print("user_id column already exists, skipping migration")
        return
    
    # Step 2: Add user_id column as nullable first
    with op.batch_alter_table('journal_entries', schema=None) as batch_op:
        batch_op.add_column(sa.Column('user_id', sa.String(length=36), nullable=True))
    
    # Step 3: Populate user_id for existing entries
    # For entries with trade_id, get user_id from the associated trade
    try:
        connection.execute(text("""
            UPDATE journal_entries 
            SET user_id = (
                SELECT user_id 
                FROM trades 
                WHERE trades.id = journal_entries.trade_id
            )
            WHERE trade_id IS NOT NULL
        """))
    except Exception as e:
        print(f"Warning: Could not update entries with trade_id: {e}")
    
    # Step 4: For entries without trade_id, assign to the first user (or delete them)
    try:
        result = connection.execute(text("SELECT id FROM users LIMIT 1"))
        first_user = result.fetchone()
        
        if first_user:
            # Assign orphaned entries to the first user
            connection.execute(text("""
                UPDATE journal_entries 
                SET user_id = :user_id
                WHERE user_id IS NULL
            """), {"user_id": first_user[0]})
        else:
            # If no users exist, delete orphaned entries
            connection.execute(text("DELETE FROM journal_entries WHERE user_id IS NULL"))
    except Exception as e:
        print(f"Warning: Could not handle orphaned entries: {e}")
        # If we can't handle orphaned entries, delete them to avoid constraint issues
        connection.execute(text("DELETE FROM journal_entries WHERE user_id IS NULL"))
    
    # Step 5: Make user_id NOT NULL and add foreign key constraint
    try:
        with op.batch_alter_table('journal_entries', schema=None) as batch_op:
            batch_op.alter_column('user_id', nullable=False)
            batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])
    except Exception as e:
        print(f"Error making user_id NOT NULL: {e}")
        # If we can't make it NOT NULL, at least add the foreign key
        with op.batch_alter_table('journal_entries', schema=None) as batch_op:
            batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('journal_entries', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_column('user_id')

    # ### end Alembic commands ###
